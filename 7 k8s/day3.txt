Kubernetes Deployment
---------------------
Kubernetes deployment is a high-level resource object by which you can manage the deployment and scaling of the applications while maintaining the desired state of the application. You can scale the containers with the help of Kubernetes deployment up and down depending on the incoming traffic. If you have performed any rolling updates with the help of deployment and after some time if you find any bugs in it then you can perform rollback also. Kubernetes deployments are deployed with the help of CLI like Kubectl it can be installed on any platform.

Before, we used ReplicaSet, ReplicaSet will create pods

Now, Deployment can create ReplicaSet and ReplicaSet will create PODS

deployment create rs---> rs will create Pods

We can update the application.




First delete the existing ReplicaSet

-- kubectl delete rs ib-rs

-- kubectl get rs

-- kubectl get pods


copy replicaset.yml to deployment.yml

cp replicaset.yml deployment.yml

vi yml --> Just change  "kind: Deployment" and "name: ib-deployment"
-----------------------------------------------------------------

and image to internetbanking for to understand better

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ib-deployment
  labels:
    app: bank
spec:
  replicas: 3
  selector:
    matchLabels:
      app: bank
  template:
    metadata:
      labels:
        app: bank
    spec:
      containers:
      - name: cont1
        image: trainerreyaz/ib-image:latest


-- kubectl create -f deployment.yml

-- kubectl get deploy   or kubectl get deployments

-- kubectl get deploy -o wide

-- kubectl get rs  -----> Deploy will create ReplicaSet

-- kubectl describe deploy ib-deployment

-- kubectl get pods

[FYI: delete the deployment: kubectl delete deploy deploymentname]

Now lets scale out and Scale IN

Scale Out
---------

-- kubectl scale deploy/ib-deployment --replicas=10

-- kubectl get pods


Scale In
--------

-- kubectl scale deploy/ib-deployment --replicas=5

-- kubectl get pods

What ever Replica set is doing Deployment is also doing the same thing

if you delete any pod, it will create immediately automatically

-- kubectl get pods

-- kubectl delete pod pod-id

-- kubectl describe pod -l app=bank | grep -i ID

(or)

-- kubectl describe pods | grep -i image   [It shows all internetbankingrepo image]

***************** Now what Deployment do additional thing is to change the application ***************

First watch pods in another terminal

-- kubectl get po --watch

-- kubectl edit deploy/ib-deployment   [change to mobilebanking]

watch pods in another terminal , first it will create a new pods and then terminate old ones

-- kubectl describe pods | grep -i image [you can see now mobilebanking image]


kubectl get events --sort-by=.metadata.creationTimestamp


============
RollOut Few commands
============

-- kubectl rollout history deploy/ib-deployment

-- kubectl rollout undo deploy/ib-deployment   [It will go back to previous application / image ]

-- kubectl get pods  [Pods are terminating and creating new pods with new image, this was not possible in ReplicaSet]

-- kubectl describe pods | grep -i image

-- kubectl rollout pause deploy/ib-deployment  --- it is like lock, cannot undo, cannot rollout to previous

-- kubectl rollout undo deploy/ib-deployment  -- not possible

-- kubectl rollout resume deploy/ib-deployment

-- kubectl rollout undo deploy/ib-deployment -- now possible

-- kubectl rollout status deploy/ib-deployment


Deployment has 2 Strategies
--------------------------
Rolling update: This is Default, When you update the application, Rolling update will delete one pod and create . One by one
Recreate: Delete all pods and create again- Downtime. Not recommended
Blue-Green Deployment: ðŸŸ¦ Blue = old version, ðŸŸ© Green = new version, Switch traffic only when the new version is fully ready
Canary Deployment:  Roll out new version to a small set of users, then gradually increase.

Example: see strategy: Recreate
-------

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ib-deployment
  labels:
    app: bank
spec:
  replicas: 3
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: bank
  template:
    metadata:
      labels:
        app: bank
    spec:
      containers:
      - name: cont1
        image: trainerreyaz/ib-image:latest


====================================================

If you want port to expose , use below code

    spec:
      containers:
      - name: cont1
        image: trainerreyaz/ib-image:latest
        ports:
        - containerPort: 8080   # Port inside the container
          hostPort: 8080        # Port on the host machine


ðŸ”¹ Explanation of Changes
---------------------------
âœ… containerPort: 8080 â†’ The app runs inside the container on port 8080.
âœ… hostPort: 8080 â†’ The container maps its 8080 port to the same port on the host machine.

ðŸ”¹ Important Notes on hostPort
----------------------------------
hostPort directly binds the container port to the host.
It works only on worker nodes where the pod runs.
If multiple pods run on the same node, you cannot use the same hostPort for all of them.
Recommended alternative: Instead of hostPort, use a Kubernetes Service (NodePort or LoadBalancer) to expose the Deployment.
------------------------

By default, a ReplicaSet (RS) only ensures that a specific number of Pods are running. However, it does not provide network access to those Pods externally.

âœ… To access your application from the internet, you need a Kubernetes Service.


=======================================================================================================================================

=======================================
ðŸš€ Kubernetes Manifest: 1 Pod with 2 Containers
===============================================

In Kubernetes, a Pod can run multiple containers that share the same network and storage. Hereâ€™s how to create a single Pod with two containers inside it.

vi pod-two-containers.yaml

apiVersion: v1
kind: Pod
metadata:
  name: two-container-pod
  labels:
    app: multi-container
spec:
  containers:
  - name: nginx-container
    image: nginx
    ports:
    - containerPort: 80
  - name: busybox-container
    image: busybox
    command: ["sh", "-c", "while true; do echo 'Hello from BusyBox'; sleep 10; done"]



-c: Tells sh to execute the following string command

-- kubectl apply -f pod-two-containers.yaml

-- kubectl get pods    [we get single pod but 2/2 meaning, 2 containers]

-- kubectl logs two-container-pod -c busybox-container

-- kubectl logs two-container-pod -c nginx-container

-- kubectl exec -it two-container-pod -c nginx-container -- sh       [-c: container]

   cd /usr/share/nginx/html

-- kubectl exec -it two-container-pod -c busybox-container -- sh
   
   ls



Kubernetes JOBS
================

Kubernetes Jobs are resources used to run batch tasks in a Kubernetes cluster. They ensure that a specified number of Pods successfully complete a task before marking the Job as done. Jobs are crucial for executing one-time or recurring tasks, such as data migrations, backups, or batch processing.

Types of Kubernetes Jobs:
===========================

Non-parallel Jobs:
------------------
These Jobs execute tasks sequentially /one by one, with only one Pod started unless it fails. The Job completes as soon as its Pod terminates successfully. It has completions parameter. Like completions: 3. The Job completes only when 3 Pods have successfully run

Parallel Jobs with a Fixed Completion Count:
-------------------------------------------
In these Jobs, multiple Pods run simultaneously to complete a task. The Job is considered complete when a specified number of Pods successfully complete their tasks. It has completions and Parallelism.
  completions: 6
  parallelism: 3

In the above example three pods are executing at a time, since we mentioned Parallelism = 3, so once the three pods are completed their tasks then next three will start execution.


Parallel Jobs with a Work Queue:
--------------------------------
These Jobs dynamically scale Pods based on workload. Pods coordinate with each other or external services to fetch and process tasks from a shared queue.

Real-world Use Cases:
======================

Non-parallel Jobs: Running one-time administrative tasks, such as database migrations or system updates.
-----------------

Parallel Jobs with a Fixed Completion Count: Processing large datasets, where data is split into chunks and processed concurrently by  
-------------------------------------------  multiple Pods.

Parallel Jobs with a Work Queue: Handling variable workloads, such as incoming requests in a web application, where Pods scale
-------------------------------  dynamically based on demand.


vi nonparallel.yml

apiVersion: batch/v1
kind: Job
metadata:
  name: non-parallel-job
spec:
  template:
    metadata:
      name: non-parallel-pod
    spec:
      containers:
      - name: non-parallel-container
        image: busybox
        command: ["echo", "Hello from the non-parallel job"]
      restartPolicy: Never
  completions: 3


busybox: BusyBox is a single executable that bundles multiple Unix utilities (like sh, ls, cat, echo, wget, grep, etc.). It is widely used in minimal containers because of its small size (~1MB) and fast startup time.

completions: 3 â†’ The Job completes only when 3 Pods have successfully run.

restartPolicy: Always, OnFailure, Never
-------------------------------
Always: Always restarts the container if it exits. Use Case: Default for Deployments & ReplicaSets
------                                               --------
OnFailure: Restarts the container only if it exits with an error (non-zero exit code). Use case: Jobs & CronJobs
----------                                                                             --------
Never: Never restarts the container, even if it fails. Use Case: Jobs & CronJobs (One-time execution)
------                                                 --------



-- kubectl apply -f nonparallel.yml

-- kubectl get pods

-- kubectl get jobs

-- kubectl logs -l job-name=non-parallel-job

-- kubectl logs podname     Ex: kubectl logs non-parallel-job-2vvf9

-- kubectl delete job jobname

In above example the pods are executing one by one.


Parallel Jobs with a Fixed Completion Count
---------------------------------------------
Use the below simple manifest file for testing Parallel Jobs with a Fixed Completion Count jobs:

vi parallelfixed.yml

apiVersion: batch/v1
kind: Job
metadata:
  name: parallel-fixed-count-job
spec:
  template:
    metadata:
      name: parallel-fixed-count-pod
    spec:
      containers:
      - name: parallel-fixed-count-container
        image: busybox
        command: ["echo", "Hello from the parallel-fixed-count job"]
      restartPolicy: Never
  completions: 6
  parallelism: 3


completions: 6 â†’ The Job completes only when 6 Pods have successfully run.
parallelism: 3 â†’ Runs 3 Pods at the same time.


-- kubectl apply -f parallelfixed.yml

-- kubectl get pods

-- kubectl get jobs

-- kubectl logs -l job-name=<job-name>

-- kubectl logs podname     Ex: kubectl logs parallel-job-2vvf9

-- kubectl delete job jobname

In the above example three pods are executing at a time, since we mentioned Parallelism = 3, so once the three pods are completed their tasks then next three will start execution.

Parallel Jobs with a Work Queue
--------------------------------
Use the below simple manifest file for testing Parallel Jobs with a Work Queue jobs:

vi parallel-work-queue-job.yaml

apiVersion: batch/v1
kind: Job
metadata:
  name: parallel-work-queue-job
spec:
  template:
    metadata:
      name: parallel-work-queue-pod
    spec:
      containers:
      - name: parallel-work-queue-container
        image: busybox
        command: ["echo", "Hello from the parallel-work-queue job"]
      restartPolicy: Never
  parallelism: 3

-- kubectl apply -f parallel-work-queue-job.yaml

-- kubectl get pods

In the above example 3 pods are started executing at a time since we mentioned Parallelism = 3 and we didnâ€™t mention any specified number of Completions.
                           

ðŸš€ Kubernetes CronJob Example
===============================

A Kubernetes CronJob is used to schedule jobs to run at specific times, just like a Linux cron job. It is useful for tasks such as backups, periodic data processing, or sending scheduled reports.


This CronJob prints "Hello from Kubernetes!" every minute.


vi cron.yml

apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello-cronjob
spec:
  schedule: "*/1 * * * *"  # Runs every minute
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello-container
            image: busybox
            command: ["sh", "-c", "echo Hello from Kubernetes!"]
          restartPolicy: Never  # Ensure job runs only once per schedule


-- kubectl apply -f cron.yaml

-- kubectl get cronjobs

-- kubectl describe cronjob cron


ðŸ”¹ View Logs of Last Run
---------------------------

-- kubectl get pods  # Get the latest pod name

-- kubectl logs <POD_NAME>

-- kubectl get cronjob

-- kubectl delete cronjob