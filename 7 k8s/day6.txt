===============================
Role-Based Access Control (RBAC)
===============================

RBAC helps you define what actions (verbs like get, list, create, delete, etc.) can be performed on specific resources (like pods, services, deployments, etc.) within specific namespaces or across the cluster.

RBAC in Kubernetes allows you to define roles and permissions for users, groups, or service accounts. It consists of four main components:

Role: A set of permissions (rules) that are defined within a namespace. Roles are used to grant access to resources within a specific namespace.
RoleBinding: Grants the permissions defined in a Role to a user or service account within a specific namespace.
-------------
ClusterRoles: Similar to roles, but apply across the entire cluster.
-------------
ClusterRoleBindings: Associate cluster roles with users, groups, or service accounts across the entire cluster.
-------------------

Authentication(who are you?) and Authorization (what can you do?)



Users vs Service Accounts
==========================
Before setting up RBAC, it’s important to understand the Kubernetes user model. There are two ways to create “users” depending on the type of access that’s required:

Users —
------
In Kubernetes, a User represents a human who authenticates to the cluster using an external service. You can use private keys (the default method), a list of usernames and passwords, or an OAuth service such as Google Accounts. Users are not managed by Kubernetes; there is no API object for them so you can’t create them using Kubectl. You must make changes at the external service provider.

Service Accounts —
-------------------
Service Accounts are token values that can be used to grant access to namespaces in your cluster. They’re designed for use by applications and system components. Unlike Users, Service Accounts are backed by Kubernetes objects and can be managed using the API.


2 Types of Practical's in RBAC
-------------------------------
1. user-based RBAC in Kubernetes
2. Service Account RBAC in Kubernetes


1. user-based RBAC in Kubernetes
------------------------------------

-- See another file for user-based RBAC in K8s and do practicals



2. Service Account RBAC in Kubernetes
-------------------------------------

Assume authentication has been done on the Kubernetes cluster by company with user jack, Let use give permissions to him to cluster only to get, list and watch

Create a namespace in Kubernetes

-- kubectl create ns dev [use if already exits]

-- kubectl config set-context --current --namespace=dev

First create a sample serviceaccount here in kubernetes called jack

Create a Serviceaccount ---> Create a ROLE(give permissions) --->  Role Binding

vi serviceaccount.yml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: jack
  namespace: dev

-- kubectl create -f serviceaccount.yml

--------------------------------------------------------------

Create a Role within the dev namespace that allows the user jack to perform certain actions on pods:

vi role.yml

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: dev-pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]


-- kubectl create -f role.yml

Since pods belong to the core API group, we use apiGroups: [""]


------------------------------------------------------------------

Next, bind the pod-reader Role to a user or service account. For simplicity, we'll bind it to a service account named jack:

This RoleBinding binds the pod-reader Role to the jack user, allowing that user to get, list, and watch pods in the dev namespace.

vi rolebinding.yml

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: dev
subjects:
- kind: User
  name: jack
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev-pod-reader
  apiGroup: rbac.authorization.k8s.io


-- kubectl create -f rolebinding.yml


Verifying Access
-----------------
To verify that the jack user has the correct permissions, you can impersonate the user using kubectl:

-- kubectl auth can-i list pods --namespace=dev --as=jack   [answer yes]

-- kubectl auth can-i create pods --namespace=dev --as=jack  [answer no]


-- kubectl get roles -n dev    [List all roles in a namespace:


-- kubectl describe rolebinding read-pods -n dev


=====================
DAEMONSET
======================

✔️ DaemonSets ensure one pod per node for system-level services.
✔️ Used for monitoring, logging, networking, and security.
✔️ Automatically adds/removes pods when nodes join/leave the cluster.


If you want to deploy only 1 pod per 1 node use DAEMONSET
it is a old version of Deployment

First delete existing deployment

-- kubectl get deploy

-- kubectl delete deploy mobilebanking-rs

-- kubectl get pods


in the below yml , only change is kind: DaemonSet (Capital D and S) and remove Replica

vi daemon.yml

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: mb-daemon
  labels:
    app: bank
spec:
  selector:
    matchLabels:
      app: bank
  template:
    metadata:
      labels:
        app: bank
    spec:
      containers:
      - name: cont1
        image: trainerreyaz/mb-image:latest


In the above manifest, we didn't mentioned any replicas, but daemonset will create one pod per node for sure.

-- kubectl create -f daemon.yml

-- kubectl get po


It shows 2 pods, because DaemonSet will create 1 pod per 1 node, so 2 nodes, 1 pod each

-- kubectl get daemonset / ds

-- kubectl get daemonset --namespace=default  [show daemonset in particular namespace]

-- kubectl delete daemonset <daemonset-name> --namespace=<namespace>

-- kubectl delete daemonset mb-daemon --namespace=default

-- kubectl get daemonset

tip:

-- kubectl delete daemonset --all --namespace=default  [to delete all daemonsets in namespace default]