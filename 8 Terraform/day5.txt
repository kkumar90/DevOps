===============
Meta arguments
================

In Terraform, meta-arguments are special arguments that you can use with resources, modules, and other blocks to control how they behave.

The most commonly used meta-arguments in Terraform include

-- count     : The "count" meta-argument allows you to specify the number of instances of a resource or module to create.

-- for_each    : The "for_each" meta-argument allows you to create multiple instances of a resource or module based on the elements of a set                      
                  It provides more control and flexibility than "count"

-- depends_on   : The depends_on meta-argument explicitly defines dependencies between resources. This ensures that one resource is
                   created or updated only after another resource has been successfully created or updated.

-- provider     : The provider meta-argument allows you to specify which provider configuration to use for a particular resource or
                  module. This is useful when you have multiple configurations for the same provider, such as when managing resources
                  in multiple regions.

-- lifecycle    : The lifecycle meta-argument allows you to control the lifecycle of a resource. It provides options to prevent the
                  destruction of resources, create resources before destroying existing ones, or ignore changes to specific attributes.
               
                  -- create_before_destroy
                  -- prevent_destroy
                  -- ignore_changes

-- ignore_changes : This meta-argument is used within the lifecycle block to instruct Terraform to ignore changes to specific
                    attributes of a resource. This is particularly useful when an attribute is managed outside of Terraform, or if you
                    want to prevent Terraform from trying to update a resource when certain attributes change.




DEPENDS-ON
===========

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "myinstance" {
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
tags = {
    Name = "DependsOn-Example"
  }
}

resource "aws_eip" "myinstance_eip" {
  instance   = aws_instance.myinstance.id
  depends_on = [aws_instance.myinstance]
}

output "elastic_ip" {
  description = "Elastic IP of the instance"
  value       = aws_eip.myinstance_eip.public_ip
}

output "instance_id" {
  description = "EC2 instance ID"
  value       = aws_instance.myinstance.id
}

-- terraform apply --auto-approve

-- terraform destroy --auto-approve





COUNT
====

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "myinstance" {
  count         = 2
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
  tags = {
    Name = "WebServer-${count.index}"
  }
}

output "instance_ids" {
  description = "List of EC2 instance IDs"
  value       = aws_instance.myinstance[*].id
}
output "instance_names" {
  description = "List of EC2 instance names"
  value       = aws_instance.myinstance[*].tags.Name
}

-- terraform init

-- terraform apply --auto-approve

-- terraform destroy --auto-approve

Above code will launch EC2 instance with identical objects that meaning  with same nam WebServer-0, WebServer-1 etc
But if you need different names?

Bad Example - The below code has 3 resource blocks of aws_instance, which will create 3 different servers with different names and
              instance types But this code will be very long. instead use Length and Count concept

vi main.tf

provider "aws" {
region = "ap-south-1"
}

resource "aws_instance" "one" {
count = "3"
ami = "ami-08ee1453725d19cdb"
instance_type = "t2.micro"
tags = {
Name = "test-server"
}
}
resource "aws_instance" "two" {
count = "3"
ami = "ami-08ee1453725d19cdb"
instance_type = "t2.small"
tags = {
Name = "dev-server"
}
}

resource "aws_instance" "three" {
count = "3"
ami = "ami-08ee1453725d19cdb"
instance_type = "t2.medium"
tags = {
Name = "prod-server"
}
}

Good Example: With Length and Count
-----------------------------------

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

variable "instance_type" {

  default = ["t2.micro", "t2.small", "t2.medium"]
}

variable "instance_name" {

  default = ["dev-server", "test-server", "prod-server"]
}

resource "aws_instance" "myinstance" {
  count         = length(var.instance_type)
  ami           = "ami-08ee1453725d19cdb"
  instance_type = var.instance_type[count.index]
  tags = {
    Name = var.instance_name[count.index]
  }
}


output "instance_ids" {
  description = "List of EC2 instance IDs"
  value       = aws_instance.myinstance[*].id
}
output "instance_names" {
  description = "List of EC2 instance names"
  value       = aws_instance.myinstance[*].tags.Name
}


-- terraform apply --auto-approve

-- terraform destroy --auto-approve

========
FOR_EACH
========

count vs for_each : count will create identical resources, for_each will create different resources

same above example can be achieved using for_each

Example 1:
----------

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "myinstance" {
  for_each      = toset(["dev-server", "test-server", "prod-server"])
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
  tags = {
    Name = "${each.key}"
  }
}

output "instance_ids" {
  description = "List of EC2 instance IDs"
  value       = { for k, v in aws_instance.myinstance : k => v.id }
}

output "instance_names" {
  description = "Instance names"
  value       = { for k, v in aws_instance.myinstance : k => v.tags.Name }
}


toset() is a function to create multiple EC2 instances from a list of names:

Terraform will generate a map of instances with keys as "dev-server", "test-server", and "prod-server".

The for expression iterates over aws_instance.myinstance
k represents the instance key (dev-server, test-server, etc.)
v.id retrieves the instance ID
The result is a map of key => instance_id

In for_each , we can play with key and value like .key and .value


-- terraform plan

-- terraform apply --auto-approve

-- terraform destroy --auto-approve

Another Optional Example:
------------------------

Note: The below code will launch 4 EC2 instances with different instance type and names

vi main.tf

variable "instances" {
  type = map(string)
  default = {
    "web-server-1" = "t2.micro"
    "web-server-2" = "t2.small"
    "app-server-1" = "t3.medium"
    "db-server-1"  = "m5.large"
  }
}

resource "aws_instance" "myinstance" {
  for_each = var.instances

  ami           = "ami-08ee1453725d19cdb"
  instance_type = each.value

  tags = {
    Name = each.key
  }
}

output "instance_ids" {
  description = "List of EC2 instance IDs"
  value       = { for k, v in aws_instance.myinstance : k => v.id }
}

output "instance_names" {
  description = "Instance names"
  value       = { for k, v in aws_instance.myinstance : k => v.tags.Name }
}

output "instance_names" {
  description = "List of instances with their Name key"
  value       = { for k, v in aws_instance.myinstance : k => { "Name" = v.tags.Name } }
}



k represents the instance key (dev-server, test-server, etc.)
v.id retrieves the instance ID
k => v.tags.Name retrives Instance Name, k => v.tags.Name (key and value both are same (app-server-1="app-server-1") like below output)
"Name" = v.tags.Name --> Print Key as Name, Value as instance name (+ Name = "app-server-1")


The last 2 outputs are like this: output "instance_names" {
------------------------------------------------

instance_names           = {
      + app-server-1 = "app-server-1"
      + db-server-1  = "db-server-1"
      + web-server-1 = "web-server-1"
      + web-server-2 = "web-server-2"
    }

If you need Output as Name: Value: output "instance_names_with_Name" {
---------------------------------------------------------------

instance_names_with_Name = {
      + app-server-1 = {
          + Name = "app-server-1"
        }
      + db-server-1  = {
          + Name = "db-server-1"
        }
      + web-server-1 = {
          + Name = "web-server-1"
        }
      + web-server-2 = {
          + Name = "web-server-2"
        }
    }


-- terraform plan

Another Optional Example:
-------------------------

vi main.tf

variable "instances" {
  type = map(object({
    instance_type = string
    availability_zone = string
  }))
  default = {
    "web-server-1" = { instance_type = "t2.micro", availability_zone = "ap-south-1a" }
    "web-server-2" = { instance_type = "t2.small", availability_zone = "ap-south-1b" }
    "app-server-1" = { instance_type = "t3.medium", availability_zone = "ap-south-1c" }
    "db-server-1"  = { instance_type = "m5.large", availability_zone = "ap-south-1a" }
  }
}

resource "aws_instance" "servers" {
  for_each = var.instances

  ami               = "ami-08ee1453725d19cdb"
  instance_type     = each.value.instance_type
  availability_zone = each.value.availability_zone

  tags = {
    Name = each.key
  }
}

-- terraform plan


IGNORE CHANGES
==============

If anyone modified the resources in AWS console which is created by TF, It will ignore that changes, it will not bring back to desired state. Actual State is AWS Console, Desired State is Statefile

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "myinstance" {
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
  tags = {
    Name = "reyaz-server"
  }
  lifecycle {
    ignore_changes = all
  }
}

output "instance_id" {
  description = "EC2 instance ID"
  value       = aws_instance.myinstance.id
}
output "instance_name" {
  description = "Instance Name"
  value       = aws_instance.myinstance.tags.Name
}


-- terraform apply --auto-approve

-- cat terraform.tfstate | grep reyaz  [This show reyaz-server]

Now, modify instance_type or tags or ami in configuration block , TF will ignore the changes while apply
example: modify instance_type = "t2.nano" and reyaz-server to hello-server

-- terraform plan  [it shows no changes]

-- terraform apply --auto-approve   [no change here as we ignored changes]

-- terraform destroy --auto-approve

Example 2:
----------


vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "web_server" {
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
  tags = {
    Name = "test-server"
  }
  lifecycle {
    ignore_changes = [
      instance_type,
      tags
    ]
  }
}

-- terraform plan

-- terraform apply --auto-approve

As you have ignored instance_type and tags, if you do any changes in those block in configuration file, terraform will ignore will apply

-- terraform destroy --auto-approve

===============
Prevent_Destory  -- resources will not delete if you give destroy command
===============

vi main.tf

provider "aws" {
region = "ap-south-1"
}

resource "aws_instance" "one" {
ami = "ami-08ee1453725d19cdb"
instance_type = "t2.micro"
tags = {
Name = "reyaz-server"
}
lifecycle{
prevent_destroy = true
}
}

-- terraform apply --auto-approve

-- terraform destroy --auto-approve    [It will not destroy as prevent_destroy is true , make it false and then destroy]


=======================
Create_before_destory
======================

If you change the instance type or instance name , security groups etc , It will change immediately ,
instance will not delete but if you want to change the image id of the EC2 instance , instance will delete first and then create a new instance with new ami-id

vi main.tf

provider "aws" {
region = "ap-south-1"
}

resource "aws_instance" "one" {
ami = "ami-08ee1453725d19cdb"
instance_type = "t2.micro"
tags = {
Name = "reyaz-server"
}
lifecycle{
create_before_destroy = true
}
}

-- terraform apply --auto-approve    

Now change the image id to ami-022ce6f32988af5fa

-- terraform apply --auto-approve    [First instance will be created and then old instance will be deleted]

Note: if you remove the code in main.tf and terraform apply , resources will be deleted

Give a try
----------
vi  main.tf

keep only provider and remove all code and give destroy

-- terraform destory --auto-approve

=====================================================
PROVIDERS
======================================================

Terraform has 3 main providers

1. Official : maintained by Terraform (AWS, Azure, GCP)
2. Partner : Maintained by terraform and organizations (Oracle, Alibaba)
3. Community : Maintained by individual


Lets use another provider, we were using AWS , lets now use GitHub


Example 1:
---------

Create a token first in GitHub --> Settings --> Developer Settings --> Personal access tokens (classic) --> Generate new token(classic)

vi main.tf

provider "github" {
  token = "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"
}

resource "github_repository" "example" {
  name        = "tf-github-repo"
  description = "created repo from tf"

  visibility = "public"

}


-- terraform init

-- terraform apply --auto-approve

Note: to destroy, in GitHub token select delete-repo option also

-- terraform destroy --auto-approve

==============
Local Provider
=============

vi main.tf

provider "local" {
}

resource "local_file" "one" {
  filename        = "test.txt"
  content = "this is from test data from tf using local provider"
}

-- terraform apply --auto-approve
-- ls
it will create a new file locally

-- terraform destroy --auto-approve


see in chatgpt to create docker and k8s if required

=======================
Terraform with Docker
======================

yum install docker -y

systemctl start docker

vi main.tf

terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 2.0"
    }
  }
}
provider "docker" {
  host = "unix:///var/run/docker.sock"  # For Linux/macOS
}

resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = false  # Removes the image when the container is deleted
}

resource "docker_container" "nginx" {
  name  = "nginx-container"
  image = docker_image.nginx.image_id

  ports {
    internal = 80  # Inside the container
    external = 8080  # Exposed on the host machine
  }
}

output "container_name" {
  value = docker_container.nginx.name
}

output "container_id" {
  value = docker_container.nginx.id
}

output "nginx_url" {
  value = "http://13.201.46.206:8080&quot;
}


-- terraform init -upgrade

-- terraform plan

-- terraform apply --auto-approve

http://13.201.46.206:8080

================================================================

setup cluster first - minikube or KOPS

vi main.tf

terraform {
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.0"
    }
  }
}

provider "kubernetes" {
  config_path = "~/.kube/config"  # Adjust if using a different kubeconfig
}
resource "kubernetes_deployment" "nginx" {
  metadata {
    name = "nginx-deployment"
    labels = {
      app = "nginx"
    }
  }

  spec {
    replicas = 2

    selector {
      match_labels = {
        app = "nginx"
      }
    }

    template {
      metadata {
        labels = {
          app = "nginx"
        }
      }

      spec {
        container {
          image = "nginx:latest"
          name  = "nginx"

          port {
            container_port = 80
          }
        }
      }
    }
  }
}

resource "kubernetes_service" "nginx" {
  metadata {
    name = "nginx-service"
  }

  spec {
    selector = {
      app = "nginx"
    }

    port {
      protocol    = "TCP"
      port        = 80
      target_port = 80
    }

    type = "LoadBalancer"
  }
}